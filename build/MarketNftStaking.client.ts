/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Addr, InstantiateMsg, ExecuteMsg, Uint128, Binary, UpdateContractInfoMsg, CreateCollectionPoolMsg, UpdateCollectionPoolMsg, Cw721ReceiveMsg, Cw1155ReceiveMsg, QueryMsg, NullableCollectionPoolInfo, CollectionPoolInfo, ArrayOfCollectionPoolInfo, ContractType, ArrayOfCollectionStakerInfo, CollectionStakerInfo, CollectionStakedTokenInfo, ContractInfo, NullableCollectionStakerInfo} from "./MarketNftStaking.types";
export interface MarketNftStakingReadOnlyInterface {
  contractAddress: string;
  getContractInfo: () => Promise<ContractInfo>;
  getCollectionPoolInfo: ({
    collectionId
  }: {
    collectionId: string;
  }) => Promise<NullableCollectionPoolInfo>;
  getCollectionPoolInfos: ({
    limit,
    offset,
    order
  }: {
    limit?: number;
    offset?: number;
    order?: number;
  }) => Promise<ArrayOfCollectionPoolInfo>;
  getUniqueCollectionStakerInfo: ({
    collectionId,
    stakerAddr
  }: {
    collectionId: string;
    stakerAddr: Addr;
  }) => Promise<NullableCollectionStakerInfo>;
  getCollectionStakerInfoByCollection: ({
    collectionId,
    limit,
    offset,
    order
  }: {
    collectionId: string;
    limit?: number;
    offset?: number;
    order?: number;
  }) => Promise<ArrayOfCollectionStakerInfo>;
  getCollectionStakerInfoByStaker: ({
    limit,
    offset,
    order,
    stakerAddr
  }: {
    limit?: number;
    offset?: number;
    order?: number;
    stakerAddr: Addr;
  }) => Promise<ArrayOfCollectionStakerInfo>;
}
export class MarketNftStakingQueryClient implements MarketNftStakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getContractInfo = this.getContractInfo.bind(this);
    this.getCollectionPoolInfo = this.getCollectionPoolInfo.bind(this);
    this.getCollectionPoolInfos = this.getCollectionPoolInfos.bind(this);
    this.getUniqueCollectionStakerInfo = this.getUniqueCollectionStakerInfo.bind(this);
    this.getCollectionStakerInfoByCollection = this.getCollectionStakerInfoByCollection.bind(this);
    this.getCollectionStakerInfoByStaker = this.getCollectionStakerInfoByStaker.bind(this);
  }

  getContractInfo = async (): Promise<ContractInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_info: {}
    });
  };
  getCollectionPoolInfo = async ({
    collectionId
  }: {
    collectionId: string;
  }): Promise<NullableCollectionPoolInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collection_pool_info: {
        collection_id: collectionId
      }
    });
  };
  getCollectionPoolInfos = async ({
    limit,
    offset,
    order
  }: {
    limit?: number;
    offset?: number;
    order?: number;
  }): Promise<ArrayOfCollectionPoolInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collection_pool_infos: {
        limit,
        offset,
        order
      }
    });
  };
  getUniqueCollectionStakerInfo = async ({
    collectionId,
    stakerAddr
  }: {
    collectionId: string;
    stakerAddr: Addr;
  }): Promise<NullableCollectionStakerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unique_collection_staker_info: {
        collection_id: collectionId,
        staker_addr: stakerAddr
      }
    });
  };
  getCollectionStakerInfoByCollection = async ({
    collectionId,
    limit,
    offset,
    order
  }: {
    collectionId: string;
    limit?: number;
    offset?: number;
    order?: number;
  }): Promise<ArrayOfCollectionStakerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collection_staker_info_by_collection: {
        collection_id: collectionId,
        limit,
        offset,
        order
      }
    });
  };
  getCollectionStakerInfoByStaker = async ({
    limit,
    offset,
    order,
    stakerAddr
  }: {
    limit?: number;
    offset?: number;
    order?: number;
    stakerAddr: Addr;
  }): Promise<ArrayOfCollectionStakerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collection_staker_info_by_staker: {
        limit,
        offset,
        order,
        staker_addr: stakerAddr
      }
    });
  };
}
export interface MarketNftStakingInterface extends MarketNftStakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateContractInfo: ({
    admin,
    nft1155ContractAddrWhitelist,
    nft721ContractAddrWhitelist,
    verifierPubkeyBase64
  }: {
    admin?: Addr;
    nft1155ContractAddrWhitelist?: Addr[];
    nft721ContractAddrWhitelist?: Addr[];
    verifierPubkeyBase64?: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createCollectionPool: ({
    collectionId,
    expiredAfter,
    rewardPerBlock
  }: {
    collectionId: string;
    expiredAfter?: number;
    rewardPerBlock: Uint128;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateCollectionPool: ({
    collectionId,
    rewardPerBlock
  }: {
    collectionId: string;
    rewardPerBlock?: Uint128;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  receiveNft: ({
    msg,
    sender,
    tokenId
  }: {
    msg?: Binary;
    sender: Addr;
    tokenId: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    from,
    msg,
    operator,
    tokenId
  }: {
    amount: Uint128;
    from?: string;
    msg: Binary;
    operator: string;
    tokenId: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    collectionId,
    withdrawNftIds,
    withdrawRewards
  }: {
    collectionId: string;
    withdrawNftIds: string[];
    withdrawRewards: boolean;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claim: ({
    collectionId
  }: {
    collectionId: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  resetEarnedRewards: ({
    collectionId,
    staker
  }: {
    collectionId: string;
    staker: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MarketNftStakingClient extends MarketNftStakingQueryClient implements MarketNftStakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateContractInfo = this.updateContractInfo.bind(this);
    this.createCollectionPool = this.createCollectionPool.bind(this);
    this.updateCollectionPool = this.updateCollectionPool.bind(this);
    this.receiveNft = this.receiveNft.bind(this);
    this.receive = this.receive.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.claim = this.claim.bind(this);
    this.resetEarnedRewards = this.resetEarnedRewards.bind(this);
  }

  updateContractInfo = async ({
    admin,
    nft1155ContractAddrWhitelist,
    nft721ContractAddrWhitelist,
    verifierPubkeyBase64
  }: {
    admin?: Addr;
    nft1155ContractAddrWhitelist?: Addr[];
    nft721ContractAddrWhitelist?: Addr[];
    verifierPubkeyBase64?: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contract_info: {
        admin,
        nft_1155_contract_addr_whitelist: nft1155ContractAddrWhitelist,
        nft_721_contract_addr_whitelist: nft721ContractAddrWhitelist,
        verifier_pubkey_base64: verifierPubkeyBase64
      }
    }, _fee, _memo, _funds);
  };
  createCollectionPool = async ({
    collectionId,
    expiredAfter,
    rewardPerBlock
  }: {
    collectionId: string;
    expiredAfter?: number;
    rewardPerBlock: Uint128;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_collection_pool: {
        collection_id: collectionId,
        expired_after: expiredAfter,
        reward_per_block: rewardPerBlock
      }
    }, _fee, _memo, _funds);
  };
  updateCollectionPool = async ({
    collectionId,
    rewardPerBlock
  }: {
    collectionId: string;
    rewardPerBlock?: Uint128;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_collection_pool: {
        collection_id: collectionId,
        reward_per_block: rewardPerBlock
      }
    }, _fee, _memo, _funds);
  };
  receiveNft = async ({
    msg,
    sender,
    tokenId
  }: {
    msg?: Binary;
    sender: Addr;
    tokenId: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive_nft: {
        msg,
        sender,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  receive = async ({
    amount,
    from,
    msg,
    operator,
    tokenId
  }: {
    amount: Uint128;
    from?: string;
    msg: Binary;
    operator: string;
    tokenId: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        from,
        msg,
        operator,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  withdraw = async ({
    collectionId,
    withdrawNftIds,
    withdrawRewards
  }: {
    collectionId: string;
    withdrawNftIds: string[];
    withdrawRewards: boolean;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        collection_id: collectionId,
        withdraw_nft_ids: withdrawNftIds,
        withdraw_rewards: withdrawRewards
      }
    }, _fee, _memo, _funds);
  };
  claim = async ({
    collectionId
  }: {
    collectionId: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim: {
        collection_id: collectionId
      }
    }, _fee, _memo, _funds);
  };
  resetEarnedRewards = async ({
    collectionId,
    staker
  }: {
    collectionId: string;
    staker: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reset_earned_rewards: {
        collection_id: collectionId,
        staker
      }
    }, _fee, _memo, _funds);
  };
}